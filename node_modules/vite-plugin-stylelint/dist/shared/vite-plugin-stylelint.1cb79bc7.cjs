'use strict';

const require$$0 = require('tty');
const pluginutils = require('@rollup/pluginutils');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e.default : e; }

const require$$0__default = /*#__PURE__*/_interopDefaultCompat(require$$0);

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var picocolors = {exports: {}};

let tty = require$$0__default;

let isColorSupported =
	!("NO_COLOR" in process.env || process.argv.includes("--no-color")) &&
	("FORCE_COLOR" in process.env ||
		process.argv.includes("--color") ||
		process.platform === "win32" ||
		(tty.isatty(1) && process.env.TERM !== "dumb") ||
		"CI" in process.env);

let formatter =
	(open, close, replace = open) =>
	input => {
		let string = "" + input;
		let index = string.indexOf(close, open.length);
		return ~index
			? open + replaceClose(string, close, replace, index) + close
			: open + string + close
	};

let replaceClose = (string, close, replace, index) => {
	let start = string.substring(0, index) + replace;
	let end = string.substring(index + close.length);
	let nextIndex = end.indexOf(close);
	return ~nextIndex ? start + replaceClose(end, close, replace, nextIndex) : start + end
};

let createColors = (enabled = isColorSupported) => ({
	isColorSupported: enabled,
	reset: enabled ? s => `\x1b[0m${s}\x1b[0m` : String,
	bold: enabled ? formatter("\x1b[1m", "\x1b[22m", "\x1b[22m\x1b[1m") : String,
	dim: enabled ? formatter("\x1b[2m", "\x1b[22m", "\x1b[22m\x1b[2m") : String,
	italic: enabled ? formatter("\x1b[3m", "\x1b[23m") : String,
	underline: enabled ? formatter("\x1b[4m", "\x1b[24m") : String,
	inverse: enabled ? formatter("\x1b[7m", "\x1b[27m") : String,
	hidden: enabled ? formatter("\x1b[8m", "\x1b[28m") : String,
	strikethrough: enabled ? formatter("\x1b[9m", "\x1b[29m") : String,
	black: enabled ? formatter("\x1b[30m", "\x1b[39m") : String,
	red: enabled ? formatter("\x1b[31m", "\x1b[39m") : String,
	green: enabled ? formatter("\x1b[32m", "\x1b[39m") : String,
	yellow: enabled ? formatter("\x1b[33m", "\x1b[39m") : String,
	blue: enabled ? formatter("\x1b[34m", "\x1b[39m") : String,
	magenta: enabled ? formatter("\x1b[35m", "\x1b[39m") : String,
	cyan: enabled ? formatter("\x1b[36m", "\x1b[39m") : String,
	white: enabled ? formatter("\x1b[37m", "\x1b[39m") : String,
	gray: enabled ? formatter("\x1b[90m", "\x1b[39m") : String,
	bgBlack: enabled ? formatter("\x1b[40m", "\x1b[49m") : String,
	bgRed: enabled ? formatter("\x1b[41m", "\x1b[49m") : String,
	bgGreen: enabled ? formatter("\x1b[42m", "\x1b[49m") : String,
	bgYellow: enabled ? formatter("\x1b[43m", "\x1b[49m") : String,
	bgBlue: enabled ? formatter("\x1b[44m", "\x1b[49m") : String,
	bgMagenta: enabled ? formatter("\x1b[45m", "\x1b[49m") : String,
	bgCyan: enabled ? formatter("\x1b[46m", "\x1b[49m") : String,
	bgWhite: enabled ? formatter("\x1b[47m", "\x1b[49m") : String,
});

picocolors.exports = createColors();
picocolors.exports.createColors = createColors;

var picocolorsExports = picocolors.exports;
const pico = /*@__PURE__*/getDefaultExportFromCjs(picocolorsExports);

const STYLELINT_SEVERITY = {
  ERROR: "error",
  WARNING: "warning"
};
const CWD = process.cwd();
const PLUGIN_NAME = "vite:stylelint";
const COLOR_MAPPING = {
  error: "red",
  warning: "yellow",
  plugin: "magenta"
};

const getOptions = ({
  test,
  dev,
  build,
  cache,
  cacheLocation,
  include,
  exclude,
  stylelintPath,
  formatter,
  lintInWorker,
  lintOnStart,
  lintDirtyOnly,
  chokidar,
  emitError,
  emitErrorAsWarning,
  emitWarning,
  emitWarningAsError,
  ...stylelintOptions
}) => ({
  test: test ?? false,
  dev: dev ?? true,
  build: build ?? false,
  cache: cache ?? true,
  cacheLocation: cacheLocation ?? ".stylelintcache",
  include: include ?? ["src/**/*.{css,scss,sass,less,styl,vue,svelte}"],
  exclude: exclude ?? ["node_modules", "virtual:"],
  stylelintPath: stylelintPath ?? "stylelint",
  formatter: formatter ?? "string",
  lintInWorker: lintInWorker ?? false,
  lintOnStart: lintOnStart ?? false,
  lintDirtyOnly: lintDirtyOnly ?? true,
  chokidar: chokidar ?? false,
  emitError: emitError ?? true,
  emitErrorAsWarning: emitErrorAsWarning ?? false,
  emitWarning: emitWarning ?? true,
  emitWarningAsError: emitWarningAsError ?? false,
  ...stylelintOptions
});
const getFilter = (options) => pluginutils.createFilter(options.include, options.exclude);
const initializeStylelint = async (options) => {
  const { stylelintPath, formatter } = options;
  try {
    const module = await import(stylelintPath);
    const stylelintInstance = (module == null ? void 0 : module.default) ?? module;
    const loadedFormatter = typeof formatter === "string" ? await stylelintInstance.formatters[formatter] : formatter;
    return { stylelintInstance, formatter: loadedFormatter };
  } catch (error) {
    throw new Error(
      `Failed to initialize Stylelint. Have you installed and configured correctly? ${error}`
    );
  }
};
const getStylelintLinterOptions = (options) => ({
  ...options,
  allowEmptyInput: true
});
const isVirtualModule = (id) => id.startsWith("virtual:") || id[0] === "\0" || !id.includes("/");
const getFilePath = (id) => pluginutils.normalizePath(id).split("?")[0];
const shouldIgnoreModule = async (id, filter, chokidar = false) => {
  if (isVirtualModule(id))
    return true;
  if (!filter(id))
    return true;
  const filePath = getFilePath(id);
  if (!chokidar && [".vue", ".svelte"].some((extname) => filePath.endsWith(extname))) {
    return !(id.includes("?") && id.includes("type=style"));
  }
  return false;
};
const colorize = (text, textType) => pico[COLOR_MAPPING[textType]](text);
const log = (text, textType, context) => {
  console.log("");
  if (context) {
    if (textType === "error")
      context.error(text);
    else if (textType === "warning")
      context.warn(text);
  } else {
    const t = colorize(`${text}  Plugin: ${colorize(PLUGIN_NAME, "plugin")}\r
`, textType);
    console.log(t);
  }
};
const lintFiles = async ({ files, stylelintInstance, formatter, options }, context) => await stylelintInstance.lint({ ...getStylelintLinterOptions(options), files }).then(async (linterResult) => {
  if (!linterResult || linterResult.results.length === 0)
    return;
  let results = linterResult.results.filter((item) => !item.ignored);
  if (!options.emitError) {
    results = results.map((item) => ({
      ...item,
      warnings: item.warnings.filter(
        (warning) => warning.severity !== STYLELINT_SEVERITY.ERROR
      )
    }));
    linterResult.errored = false;
  }
  if (!options.emitWarning) {
    results = results.map((item) => ({
      ...item,
      warnings: item.warnings.filter(
        (warning) => warning.severity !== STYLELINT_SEVERITY.WARNING
      )
    }));
  }
  results = results.filter((item) => item.warnings.length > 0);
  if (results.length === 0)
    return;
  linterResult.results = results;
  const formattedText = formatter(results, linterResult);
  const formattedTextType = linterResult.errored ? options.emitErrorAsWarning ? "warning" : "error" : options.emitWarningAsError ? "error" : "warning";
  return log(formattedText, formattedTextType, context);
});

exports.CWD = CWD;
exports.PLUGIN_NAME = PLUGIN_NAME;
exports.getFilePath = getFilePath;
exports.getFilter = getFilter;
exports.getOptions = getOptions;
exports.initializeStylelint = initializeStylelint;
exports.lintFiles = lintFiles;
exports.shouldIgnoreModule = shouldIgnoreModule;
